\documentclass[a4paper,12pt]{article}	% тип документа

\usepackage[a4paper,top=1.3cm,bottom=2cm,left=1.5cm,right=1.5cm,marginparwidth=0.75cm]{geometry} % field settings

\usepackage[T2A]{fontenc}		% кодировка
\usepackage[utf8]{inputenc}		% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{indentfirst}

%Piece of code
\usepackage{listings}
\usepackage{xcolor}
\lstset
{
    language=C++,
    backgroundcolor=\color{black!4}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

%Drawings
\usepackage{graphicx}

\usepackage{wrapfig}

\usepackage{multirow}

\usepackage{float}

\usepackage{wasysym}

\usepackage[T1]{fontenc}
\usepackage{titlesec}

\setlength{\parindent}{3ex}

%Quatation
\usepackage{csquotes}

% Literature
\addto\captions{\def\refname{Литература.}}

%Header
\title{
	\center{\textbf{CQ 22.}}
	}


\begin{document}	% the beginning of the document

\maketitle


\section{Какие уровни входят в модель OSI и за что они отвечают?}
	
	В модель OSI входят уровни:
	
	\begin{itemize}
	
		\item Физический: работа со средой и
передача данных.
		
		\item Канальный: физическая адресация (с использованием MAC-адресов)
		
		\item Сетевой: логическая адресация.
		
		\item Транспортный: прямая передача данных и контроль этой передачи.
		
		\item Сеансовый: поддержка сеанса связи (позволяет приложениям взаимодействовать между собой длительное время).
		
		\item Представление: преобразование протоколов и кодирование/декодирование данных.
		
		\item Прикладной: обеспечение доступа к сетевым службам.
			
	\end{itemize}
	
	
\section{Перечислите основные особенности протоколов TCP и UDP?}

	Основные особенности протокола TCP:
	
	\begin{itemize}
	
		\item Надёжный: даёт гарантию, что сообщение будет доставлено сообщений; обрабатывает ошибки.
		
		\item Требует установки логического соединения (служебного).
		
		\item Поддерживает режим соединения один с одним (1-1).
		
		\item Потокоориентирован, данные представляют собой поток байт. (В этом плане похож на std::cin/cout: данные поступают и выдаются надлежащим -- см. след. пункт -- образом).
		
		\item Контролирует порядок в работе с данными и их передаче далее.
	
	\end{itemize}
	
	Основные особенности протокола UDP:
	
	\begin{itemize}
	
		\item Ненадёжный: нет гарантии доставки сообщений; нет возможности обрабатывать ошибки.
		
		\item Не требует установки логического соединения.
		
		\item Поддерживает как режим соединения один с одним (1-1), так и один со многими (1-N).
		
		\item Ориентирован на сообщения (вывод данных нуждается в дополнительной обработке).
	
	\end{itemize}
	
	Протокол UDP используется, когда есть необходимость в более быстрой работе с данными и не страшно потерять малую информацию, получив целостное представление обо всём остальном. Когда же ограничений по времени нет, то используется протокол TCP.	
	
	
\section{Какие данные необходимы для сетевого взаимодействия?}

	Для организации сетевого взаимодействия необходимо обеспечить подключение клиента к серверу (установить соединение), взаимную отправку и получение данных.
	
	Сетевое взаимодействие организуется на основании некоторого протокола, поэтому необходимо определить какой будет использоваться протокол.	
	
	Далее, чтобы подключить клиента к какому-либо серверу, используя какой-либо протокол, необходимо знать IP-адрес хоста клиента и IP-адрес хоста сервера (т.е. получателя), например, в IPv4 или IPv6 версии, а также используемые ими номера портов. Причём не все номера портов могут быть задействованы произвольным образом (скорее всего, будут использоваться пользовательские или динамические). Кроме того, IP-адреса могут быть определны по DNS-именам хостов клиента и сервера (соответсвенно, требуется знать либо сам IP-адрес, либо его DNS-имя).
	
	Пара из IP-адреса и номера порта формирует т.н. endpoint (конечную точку). Эти конечные точки и используются для подключения клиента к серверу, а также для принятия самим сервером любых или конкретных подключений. Это уже осуществляется с помощью т.н. sockets (сокетов) -- интерфейсов для обеспечения обмена данными (отправки/получения сообщений) между процессами -- при связывании сокета с конечной точкой.
	
	Итак, необходимы данные об:
	
	\begin{itemize}
	
		\item используемом протоколе;
		
		\item используемых IP-адресах (хостов клиента и сервера);
		
		\item используемых портах (хостов клиента и сервера).
	
	\end{itemize}
	
	
\section{Какие функции выполняют пассивные и активные сокеты?}

	Сокеты, как уже упоминалось, являются интерфейсами для обеспечения обмена данными между процессами (в нашем случае между клиентом и сервером), поэтому они решают задачи:

	\begin{itemize}
	
		\item установки соединения;
		
		\item обмена данными.
			
	\end{itemize}	

	Но в действительности, если сокет выполняет обе задачи, то его называют активным. Если же сокет решает лишь задачу установки соединения, то он называется пассивным. Пассивный сокет бывает удобно использовать для установки соединения именно на сервере (причём в рамках протокола TCP), когда требуется подключить произвольного клиента (просто ожидается подключение любого клиента в любой момент). Затем полученное соединение обычно перенаправляется на активный сокет. И т.о., активные сокеты клиента и сервера оказываются связанными: соединение установлено (и можно обмениваться данными, используя уже активные сокеты).
	
	Стоит отметить, что сокеты в Boost.Asio не являются потокобезопасными.
	
	
		
\section{Как устанавливается логическое соединение протокола TCP?}
	
	Прежде чем клиент попытается подключиться к серверу, сервер должен сначала подключиться к порту и прослушивать его, чтобы открыть его для соединений (пассивное открытие -- см. пред. вопрос). Как только пассивное открытие установлено, клиент может установить соединение, инициировав активное открытие с помощью трёхэтапного рукопожатия (handshake). Приведём формальное описание (описание на основании Boost.Asio см. в конце вопроса -- можно сравнить):
	
	\begin{itemize}
	
		\item Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом SYN:
		
		\begin{itemize}
		
			\item Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет для обслуживания нового клиента.
			
			\item В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED.
			
			\item В случае неудачи сервер посылает клиенту сегмент с флагом RST
		
		\end{itemize}
		
		\item Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK:
		
		\begin{itemize}
		
			\item Если клиент одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED.
			
			\item Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться.
			
			\item Если клиент не получает ответа в течение некоторого времени, то он повторяет процесс соединения заново.
		
		\end{itemize}
		
	\item Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED.
	
		\begin{itemize}
		
			\item В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED
					
		\end{itemize}
	
	\end{itemize}
	
	Шаги 1 и 2 устанавливают и подтверждают порядковый номер для одного направления. Шаги 2 и 3 устанавливают и подтверждают порядковый номер для другого направления. После выполнения этих шагов и клиент, и сервер получают подтверждения, и устанавливается двусторонняя связь.

	Установку логического соединения протокола TCP можно описать более просто, используя средства высокоуровневой обёртки Boost.Asio. В принципе после установки клиентом пассивного открытия клиент также устанавливает двустороннее соединение c сервером с помощью метода connect() клиентского сокета:
	
	\begin{itemize}
	
		\item Устанавливается пассивная привязка клиентского сокета к серверу (использован метод bind() пассивного серверного сокета).
		
		\item Устанавливается прослушивание по заданному порту сервера (к которому обращается клиент) с ограничением возможного количества клиентских подключений (метод listen() пассивного сокета).
		
		\item Создаётся активный серверный сокет и далее с помощью метода accept() (пассивного сокета, с помощью которого и выполнялась исходная привязка) устанавливается конечное соединение активных сокетов на стороне клиента и сервера: клиент получает ответ на вызов метода connect() своего сокета. В случае успеха связь установлена (помешать может, например, размер, указанный ранее при вызове метода listen()), может происходить обмен данными. Пассивный сокет сыграл роль посредника.
	
	\end{itemize}


\newpage

	
\addcontentsline{toc}{section}{Literature}
 
	\begin{thebibliography}{}
	
		\bibitem{litlink1} Конспект. И.С. Макаров.
		
		\bibitem{litlink2} https://ru.wikipedia.org
		
		\bibitem{litlink3} https://en.wikipedia.org
		
	\end{thebibliography}


\end{document} % end of the document
